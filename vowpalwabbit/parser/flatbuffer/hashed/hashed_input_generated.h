// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HASHEDINPUT_H_
#define FLATBUFFERS_GENERATED_HASHEDINPUT_H_

#include "flatbuffers/flatbuffers.h"

struct Feature;
struct FeatureBuilder;

struct Namespace;
struct NamespaceBuilder;

struct Label;
struct LabelBuilder;

struct Example;
struct ExampleBuilder;

struct ExampleCollection;
struct ExampleCollectionBuilder;

struct Feature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_HASH = 6
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  uint64_t hash() const {
    return GetField<uint64_t>(VT_HASH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<uint64_t>(verifier, VT_HASH) &&
           verifier.EndTable();
  }
};

struct FeatureBuilder {
  typedef Feature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(Feature::VT_VALUE, value, 0.0f);
  }
  void add_hash(uint64_t hash) {
    fbb_.AddElement<uint64_t>(Feature::VT_HASH, hash, 0);
  }
  explicit FeatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FeatureBuilder &operator=(const FeatureBuilder &);
  flatbuffers::Offset<Feature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Feature>(end);
    return o;
  }
};

inline flatbuffers::Offset<Feature> CreateFeature(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f,
    uint64_t hash = 0) {
  FeatureBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Namespace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NamespaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FEATURES = 6
  };
  uint64_t name() const {
    return GetField<uint64_t>(VT_NAME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Feature>> *features() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Feature>> *>(VT_FEATURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NAME) &&
           VerifyOffset(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           verifier.EndTable();
  }
};

struct NamespaceBuilder {
  typedef Namespace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(uint64_t name) {
    fbb_.AddElement<uint64_t>(Namespace::VT_NAME, name, 0);
  }
  void add_features(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Feature>>> features) {
    fbb_.AddOffset(Namespace::VT_FEATURES, features);
  }
  explicit NamespaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NamespaceBuilder &operator=(const NamespaceBuilder &);
  flatbuffers::Offset<Namespace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Namespace>(end);
    return o;
  }
};

inline flatbuffers::Offset<Namespace> CreateNamespace(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Feature>>> features = 0) {
  NamespaceBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_features(features);
  return builder_.Finish();
}

inline flatbuffers::Offset<Namespace> CreateNamespaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t name = 0,
    const std::vector<flatbuffers::Offset<Feature>> *features = nullptr) {
  auto features__ = features ? _fbb.CreateVector<flatbuffers::Offset<Feature>>(*features) : 0;
  return CreateNamespace(
      _fbb,
      name,
      features__);
}

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_WEIGHT = 6
  };
  float label() const {
    return GetField<float>(VT_LABEL, 0.0f);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LABEL) &&
           VerifyField<float>(verifier, VT_WEIGHT) &&
           verifier.EndTable();
  }
};

struct LabelBuilder {
  typedef Label Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(float label) {
    fbb_.AddElement<float>(Label::VT_LABEL, label, 0.0f);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(Label::VT_WEIGHT, weight, 0.0f);
  }
  explicit LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LabelBuilder &operator=(const LabelBuilder &);
  flatbuffers::Offset<Label> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Label>(end);
    return o;
  }
};

inline flatbuffers::Offset<Label> CreateLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    float label = 0.0f,
    float weight = 0.0f) {
  LabelBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_label(label);
  return builder_.Finish();
}

struct Example FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExampleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAMESPACES = 4,
    VT_LABEL = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Namespace>> *namespaces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Namespace>> *>(VT_NAMESPACES);
  }
  const Label *label() const {
    return GetPointer<const Label *>(VT_LABEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAMESPACES) &&
           verifier.VerifyVector(namespaces()) &&
           verifier.VerifyVectorOfTables(namespaces()) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyTable(label()) &&
           verifier.EndTable();
  }
};

struct ExampleBuilder {
  typedef Example Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_namespaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Namespace>>> namespaces) {
    fbb_.AddOffset(Example::VT_NAMESPACES, namespaces);
  }
  void add_label(flatbuffers::Offset<Label> label) {
    fbb_.AddOffset(Example::VT_LABEL, label);
  }
  explicit ExampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExampleBuilder &operator=(const ExampleBuilder &);
  flatbuffers::Offset<Example> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Example>(end);
    return o;
  }
};

inline flatbuffers::Offset<Example> CreateExample(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Namespace>>> namespaces = 0,
    flatbuffers::Offset<Label> label = 0) {
  ExampleBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_namespaces(namespaces);
  return builder_.Finish();
}

inline flatbuffers::Offset<Example> CreateExampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Namespace>> *namespaces = nullptr,
    flatbuffers::Offset<Label> label = 0) {
  auto namespaces__ = namespaces ? _fbb.CreateVector<flatbuffers::Offset<Namespace>>(*namespaces) : 0;
  return CreateExample(
      _fbb,
      namespaces__,
      label);
}

struct ExampleCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExampleCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXAMPLES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Example>> *examples() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Example>> *>(VT_EXAMPLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXAMPLES) &&
           verifier.VerifyVector(examples()) &&
           verifier.VerifyVectorOfTables(examples()) &&
           verifier.EndTable();
  }
};

struct ExampleCollectionBuilder {
  typedef ExampleCollection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_examples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Example>>> examples) {
    fbb_.AddOffset(ExampleCollection::VT_EXAMPLES, examples);
  }
  explicit ExampleCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExampleCollectionBuilder &operator=(const ExampleCollectionBuilder &);
  flatbuffers::Offset<ExampleCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExampleCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExampleCollection> CreateExampleCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Example>>> examples = 0) {
  ExampleCollectionBuilder builder_(_fbb);
  builder_.add_examples(examples);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExampleCollection> CreateExampleCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Example>> *examples = nullptr) {
  auto examples__ = examples ? _fbb.CreateVector<flatbuffers::Offset<Example>>(*examples) : 0;
  return CreateExampleCollection(
      _fbb,
      examples__);
}

inline const ExampleCollection *GetExampleCollection(const void *buf) {
  return flatbuffers::GetRoot<ExampleCollection>(buf);
}

inline const ExampleCollection *GetSizePrefixedExampleCollection(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ExampleCollection>(buf);
}

inline bool VerifyExampleCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ExampleCollection>(nullptr);
}

inline bool VerifySizePrefixedExampleCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ExampleCollection>(nullptr);
}

inline void FinishExampleCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ExampleCollection> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedExampleCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ExampleCollection> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_HASHEDINPUT_H_
