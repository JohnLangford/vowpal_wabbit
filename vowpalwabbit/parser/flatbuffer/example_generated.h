// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXAMPLE_VW_PARSERS_FLATBUFFER_H_
#define FLATBUFFERS_GENERATED_EXAMPLE_VW_PARSERS_FLATBUFFER_H_

#include "flatbuffers/flatbuffers.h"

namespace VW {
namespace parsers {
namespace flatbuffer {

struct Feature;
struct FeatureBuilder;

struct Namespace;
struct NamespaceBuilder;

struct SimpleLabel;
struct SimpleLabelBuilder;

struct CB_class;
struct CB_classBuilder;

struct CBLabel;
struct CBLabelBuilder;

struct CB_EVAL_Label;
struct CB_EVAL_LabelBuilder;

struct MultiLabel;
struct MultiLabelBuilder;

struct MultiClass;
struct MultiClassBuilder;

struct action_score;
struct action_scoreBuilder;

struct CCB_outcome;
struct CCB_outcomeBuilder;

struct CCBLabel;
struct CCBLabelBuilder;

struct wclass;
struct wclassBuilder;

struct CS_Label;
struct CS_LabelBuilder;

struct no_label;
struct no_labelBuilder;

struct Example;
struct ExampleBuilder;

struct ExampleCollection;
struct ExampleCollectionBuilder;

enum CCB_example_type {
  CCB_example_type_unset = 0,
  CCB_example_type_shared = 1,
  CCB_example_type_action = 2,
  CCB_example_type_slot = 3,
  CCB_example_type_MIN = CCB_example_type_unset,
  CCB_example_type_MAX = CCB_example_type_slot
};

inline const CCB_example_type (&EnumValuesCCB_example_type())[4] {
  static const CCB_example_type values[] = {
    CCB_example_type_unset,
    CCB_example_type_shared,
    CCB_example_type_action,
    CCB_example_type_slot
  };
  return values;
}

inline const char * const *EnumNamesCCB_example_type() {
  static const char * const names[5] = {
    "unset",
    "shared",
    "action",
    "slot",
    nullptr
  };
  return names;
}

inline const char *EnumNameCCB_example_type(CCB_example_type e) {
  if (flatbuffers::IsOutRange(e, CCB_example_type_unset, CCB_example_type_slot)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCCB_example_type()[index];
}

enum Label {
  Label_NONE = 0,
  Label_SimpleLabel = 1,
  Label_CBLabel = 2,
  Label_CCBLabel = 3,
  Label_MultiClass = 4,
  Label_MultiLabel = 5,
  Label_CB_EVAL_Label = 6,
  Label_CS_Label = 7,
  Label_no_label = 8,
  Label_MIN = Label_NONE,
  Label_MAX = Label_no_label
};

inline const Label (&EnumValuesLabel())[9] {
  static const Label values[] = {
    Label_NONE,
    Label_SimpleLabel,
    Label_CBLabel,
    Label_CCBLabel,
    Label_MultiClass,
    Label_MultiLabel,
    Label_CB_EVAL_Label,
    Label_CS_Label,
    Label_no_label
  };
  return values;
}

inline const char * const *EnumNamesLabel() {
  static const char * const names[10] = {
    "NONE",
    "SimpleLabel",
    "CBLabel",
    "CCBLabel",
    "MultiClass",
    "MultiLabel",
    "CB_EVAL_Label",
    "CS_Label",
    "no_label",
    nullptr
  };
  return names;
}

inline const char *EnumNameLabel(Label e) {
  if (flatbuffers::IsOutRange(e, Label_NONE, Label_no_label)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLabel()[index];
}

template<typename T> struct LabelTraits {
  static const Label enum_value = Label_NONE;
};

template<> struct LabelTraits<VW::parsers::flatbuffer::SimpleLabel> {
  static const Label enum_value = Label_SimpleLabel;
};

template<> struct LabelTraits<VW::parsers::flatbuffer::CBLabel> {
  static const Label enum_value = Label_CBLabel;
};

template<> struct LabelTraits<VW::parsers::flatbuffer::CCBLabel> {
  static const Label enum_value = Label_CCBLabel;
};

template<> struct LabelTraits<VW::parsers::flatbuffer::MultiClass> {
  static const Label enum_value = Label_MultiClass;
};

template<> struct LabelTraits<VW::parsers::flatbuffer::MultiLabel> {
  static const Label enum_value = Label_MultiLabel;
};

template<> struct LabelTraits<VW::parsers::flatbuffer::CB_EVAL_Label> {
  static const Label enum_value = Label_CB_EVAL_Label;
};

template<> struct LabelTraits<VW::parsers::flatbuffer::CS_Label> {
  static const Label enum_value = Label_CS_Label;
};

template<> struct LabelTraits<VW::parsers::flatbuffer::no_label> {
  static const Label enum_value = Label_no_label;
};

bool VerifyLabel(flatbuffers::Verifier &verifier, const void *obj, Label type);
bool VerifyLabelVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Feature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FeatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6,
    VT_HASH = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  uint64_t hash() const {
    return GetField<uint64_t>(VT_HASH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<uint64_t>(verifier, VT_HASH) &&
           verifier.EndTable();
  }
};

struct FeatureBuilder {
  typedef Feature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Feature::VT_NAME, name);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(Feature::VT_VALUE, value, 0.0f);
  }
  void add_hash(uint64_t hash) {
    fbb_.AddElement<uint64_t>(Feature::VT_HASH, hash, 0);
  }
  explicit FeatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FeatureBuilder &operator=(const FeatureBuilder &);
  flatbuffers::Offset<Feature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Feature>(end);
    return o;
  }
};

inline flatbuffers::Offset<Feature> CreateFeature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float value = 0.0f,
    uint64_t hash = 0) {
  FeatureBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Feature> CreateFeatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float value = 0.0f,
    uint64_t hash = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return VW::parsers::flatbuffer::CreateFeature(
      _fbb,
      name__,
      value,
      hash);
}

struct Namespace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NamespaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_HASH = 6,
    VT_FEATURES = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t hash() const {
    return GetField<uint64_t>(VT_HASH, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Feature>> *features() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Feature>> *>(VT_FEATURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_HASH) &&
           VerifyOffset(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           verifier.EndTable();
  }
};

struct NamespaceBuilder {
  typedef Namespace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Namespace::VT_NAME, name);
  }
  void add_hash(uint64_t hash) {
    fbb_.AddElement<uint64_t>(Namespace::VT_HASH, hash, 0);
  }
  void add_features(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Feature>>> features) {
    fbb_.AddOffset(Namespace::VT_FEATURES, features);
  }
  explicit NamespaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NamespaceBuilder &operator=(const NamespaceBuilder &);
  flatbuffers::Offset<Namespace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Namespace>(end);
    return o;
  }
};

inline flatbuffers::Offset<Namespace> CreateNamespace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t hash = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Feature>>> features = 0) {
  NamespaceBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_features(features);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Namespace> CreateNamespaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t hash = 0,
    const std::vector<flatbuffers::Offset<VW::parsers::flatbuffer::Feature>> *features = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto features__ = features ? _fbb.CreateVector<flatbuffers::Offset<VW::parsers::flatbuffer::Feature>>(*features) : 0;
  return VW::parsers::flatbuffer::CreateNamespace(
      _fbb,
      name__,
      hash,
      features__);
}

struct SimpleLabel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SimpleLabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_WEIGHT = 6
  };
  float label() const {
    return GetField<float>(VT_LABEL, 0.0f);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LABEL) &&
           VerifyField<float>(verifier, VT_WEIGHT) &&
           verifier.EndTable();
  }
};

struct SimpleLabelBuilder {
  typedef SimpleLabel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(float label) {
    fbb_.AddElement<float>(SimpleLabel::VT_LABEL, label, 0.0f);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(SimpleLabel::VT_WEIGHT, weight, 0.0f);
  }
  explicit SimpleLabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SimpleLabelBuilder &operator=(const SimpleLabelBuilder &);
  flatbuffers::Offset<SimpleLabel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SimpleLabel>(end);
    return o;
  }
};

inline flatbuffers::Offset<SimpleLabel> CreateSimpleLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    float label = 0.0f,
    float weight = 0.0f) {
  SimpleLabelBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_label(label);
  return builder_.Finish();
}

struct CB_class FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CB_classBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COST = 4,
    VT_ACTION = 6,
    VT_PROBABILITY = 8,
    VT_PARTIAL_PRED = 10
  };
  float cost() const {
    return GetField<float>(VT_COST, 0.0f);
  }
  uint32_t action() const {
    return GetField<uint32_t>(VT_ACTION, 0);
  }
  float probability() const {
    return GetField<float>(VT_PROBABILITY, 0.0f);
  }
  float partial_pred() const {
    return GetField<float>(VT_PARTIAL_PRED, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_COST) &&
           VerifyField<uint32_t>(verifier, VT_ACTION) &&
           VerifyField<float>(verifier, VT_PROBABILITY) &&
           VerifyField<float>(verifier, VT_PARTIAL_PRED) &&
           verifier.EndTable();
  }
};

struct CB_classBuilder {
  typedef CB_class Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cost(float cost) {
    fbb_.AddElement<float>(CB_class::VT_COST, cost, 0.0f);
  }
  void add_action(uint32_t action) {
    fbb_.AddElement<uint32_t>(CB_class::VT_ACTION, action, 0);
  }
  void add_probability(float probability) {
    fbb_.AddElement<float>(CB_class::VT_PROBABILITY, probability, 0.0f);
  }
  void add_partial_pred(float partial_pred) {
    fbb_.AddElement<float>(CB_class::VT_PARTIAL_PRED, partial_pred, 0.0f);
  }
  explicit CB_classBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CB_classBuilder &operator=(const CB_classBuilder &);
  flatbuffers::Offset<CB_class> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CB_class>(end);
    return o;
  }
};

inline flatbuffers::Offset<CB_class> CreateCB_class(
    flatbuffers::FlatBufferBuilder &_fbb,
    float cost = 0.0f,
    uint32_t action = 0,
    float probability = 0.0f,
    float partial_pred = 0.0f) {
  CB_classBuilder builder_(_fbb);
  builder_.add_partial_pred(partial_pred);
  builder_.add_probability(probability);
  builder_.add_action(action);
  builder_.add_cost(cost);
  return builder_.Finish();
}

struct CBLabel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CBLabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEIGHT = 4,
    VT_COSTS = 6
  };
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::CB_class>> *costs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::CB_class>> *>(VT_COSTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WEIGHT) &&
           VerifyOffset(verifier, VT_COSTS) &&
           verifier.VerifyVector(costs()) &&
           verifier.VerifyVectorOfTables(costs()) &&
           verifier.EndTable();
  }
};

struct CBLabelBuilder {
  typedef CBLabel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weight(float weight) {
    fbb_.AddElement<float>(CBLabel::VT_WEIGHT, weight, 0.0f);
  }
  void add_costs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::CB_class>>> costs) {
    fbb_.AddOffset(CBLabel::VT_COSTS, costs);
  }
  explicit CBLabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CBLabelBuilder &operator=(const CBLabelBuilder &);
  flatbuffers::Offset<CBLabel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CBLabel>(end);
    return o;
  }
};

inline flatbuffers::Offset<CBLabel> CreateCBLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    float weight = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::CB_class>>> costs = 0) {
  CBLabelBuilder builder_(_fbb);
  builder_.add_costs(costs);
  builder_.add_weight(weight);
  return builder_.Finish();
}

inline flatbuffers::Offset<CBLabel> CreateCBLabelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float weight = 0.0f,
    const std::vector<flatbuffers::Offset<VW::parsers::flatbuffer::CB_class>> *costs = nullptr) {
  auto costs__ = costs ? _fbb.CreateVector<flatbuffers::Offset<VW::parsers::flatbuffer::CB_class>>(*costs) : 0;
  return VW::parsers::flatbuffer::CreateCBLabel(
      _fbb,
      weight,
      costs__);
}

struct CB_EVAL_Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CB_EVAL_LabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_EVENT = 6
  };
  uint32_t action() const {
    return GetField<uint32_t>(VT_ACTION, 0);
  }
  const VW::parsers::flatbuffer::CBLabel *event() const {
    return GetPointer<const VW::parsers::flatbuffer::CBLabel *>(VT_EVENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACTION) &&
           VerifyOffset(verifier, VT_EVENT) &&
           verifier.VerifyTable(event()) &&
           verifier.EndTable();
  }
};

struct CB_EVAL_LabelBuilder {
  typedef CB_EVAL_Label Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(uint32_t action) {
    fbb_.AddElement<uint32_t>(CB_EVAL_Label::VT_ACTION, action, 0);
  }
  void add_event(flatbuffers::Offset<VW::parsers::flatbuffer::CBLabel> event) {
    fbb_.AddOffset(CB_EVAL_Label::VT_EVENT, event);
  }
  explicit CB_EVAL_LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CB_EVAL_LabelBuilder &operator=(const CB_EVAL_LabelBuilder &);
  flatbuffers::Offset<CB_EVAL_Label> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CB_EVAL_Label>(end);
    return o;
  }
};

inline flatbuffers::Offset<CB_EVAL_Label> CreateCB_EVAL_Label(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t action = 0,
    flatbuffers::Offset<VW::parsers::flatbuffer::CBLabel> event = 0) {
  CB_EVAL_LabelBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_action(action);
  return builder_.Finish();
}

struct MultiLabel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MultiLabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABELS = 4
  };
  const flatbuffers::Vector<uint32_t> *labels() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_LABELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABELS) &&
           verifier.VerifyVector(labels()) &&
           verifier.EndTable();
  }
};

struct MultiLabelBuilder {
  typedef MultiLabel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_labels(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> labels) {
    fbb_.AddOffset(MultiLabel::VT_LABELS, labels);
  }
  explicit MultiLabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MultiLabelBuilder &operator=(const MultiLabelBuilder &);
  flatbuffers::Offset<MultiLabel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MultiLabel>(end);
    return o;
  }
};

inline flatbuffers::Offset<MultiLabel> CreateMultiLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> labels = 0) {
  MultiLabelBuilder builder_(_fbb);
  builder_.add_labels(labels);
  return builder_.Finish();
}

inline flatbuffers::Offset<MultiLabel> CreateMultiLabelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *labels = nullptr) {
  auto labels__ = labels ? _fbb.CreateVector<uint32_t>(*labels) : 0;
  return VW::parsers::flatbuffer::CreateMultiLabel(
      _fbb,
      labels__);
}

struct MultiClass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MultiClassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_WEIGHT = 6
  };
  uint32_t label() const {
    return GetField<uint32_t>(VT_LABEL, 0);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LABEL) &&
           VerifyField<float>(verifier, VT_WEIGHT) &&
           verifier.EndTable();
  }
};

struct MultiClassBuilder {
  typedef MultiClass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(uint32_t label) {
    fbb_.AddElement<uint32_t>(MultiClass::VT_LABEL, label, 0);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(MultiClass::VT_WEIGHT, weight, 0.0f);
  }
  explicit MultiClassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MultiClassBuilder &operator=(const MultiClassBuilder &);
  flatbuffers::Offset<MultiClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MultiClass>(end);
    return o;
  }
};

inline flatbuffers::Offset<MultiClass> CreateMultiClass(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t label = 0,
    float weight = 0.0f) {
  MultiClassBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_label(label);
  return builder_.Finish();
}

struct action_score FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef action_scoreBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_SCORE = 6
  };
  uint32_t action() const {
    return GetField<uint32_t>(VT_ACTION, 0);
  }
  float score() const {
    return GetField<float>(VT_SCORE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACTION) &&
           VerifyField<float>(verifier, VT_SCORE) &&
           verifier.EndTable();
  }
};

struct action_scoreBuilder {
  typedef action_score Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(uint32_t action) {
    fbb_.AddElement<uint32_t>(action_score::VT_ACTION, action, 0);
  }
  void add_score(float score) {
    fbb_.AddElement<float>(action_score::VT_SCORE, score, 0.0f);
  }
  explicit action_scoreBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  action_scoreBuilder &operator=(const action_scoreBuilder &);
  flatbuffers::Offset<action_score> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<action_score>(end);
    return o;
  }
};

inline flatbuffers::Offset<action_score> Createaction_score(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t action = 0,
    float score = 0.0f) {
  action_scoreBuilder builder_(_fbb);
  builder_.add_score(score);
  builder_.add_action(action);
  return builder_.Finish();
}

struct CCB_outcome FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CCB_outcomeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COST = 4,
    VT_PROBABILITIES = 6
  };
  float cost() const {
    return GetField<float>(VT_COST, 0.0f);
  }
  const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::action_score>> *probabilities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::action_score>> *>(VT_PROBABILITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_COST) &&
           VerifyOffset(verifier, VT_PROBABILITIES) &&
           verifier.VerifyVector(probabilities()) &&
           verifier.VerifyVectorOfTables(probabilities()) &&
           verifier.EndTable();
  }
};

struct CCB_outcomeBuilder {
  typedef CCB_outcome Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cost(float cost) {
    fbb_.AddElement<float>(CCB_outcome::VT_COST, cost, 0.0f);
  }
  void add_probabilities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::action_score>>> probabilities) {
    fbb_.AddOffset(CCB_outcome::VT_PROBABILITIES, probabilities);
  }
  explicit CCB_outcomeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CCB_outcomeBuilder &operator=(const CCB_outcomeBuilder &);
  flatbuffers::Offset<CCB_outcome> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CCB_outcome>(end);
    return o;
  }
};

inline flatbuffers::Offset<CCB_outcome> CreateCCB_outcome(
    flatbuffers::FlatBufferBuilder &_fbb,
    float cost = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::action_score>>> probabilities = 0) {
  CCB_outcomeBuilder builder_(_fbb);
  builder_.add_probabilities(probabilities);
  builder_.add_cost(cost);
  return builder_.Finish();
}

inline flatbuffers::Offset<CCB_outcome> CreateCCB_outcomeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float cost = 0.0f,
    const std::vector<flatbuffers::Offset<VW::parsers::flatbuffer::action_score>> *probabilities = nullptr) {
  auto probabilities__ = probabilities ? _fbb.CreateVector<flatbuffers::Offset<VW::parsers::flatbuffer::action_score>>(*probabilities) : 0;
  return VW::parsers::flatbuffer::CreateCCB_outcome(
      _fbb,
      cost,
      probabilities__);
}

struct CCBLabel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CCBLabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXAMPLE_TYPE = 4,
    VT_OUTCOME = 6,
    VT_EXPLICIT_INCLUDED_ACTIONS = 8,
    VT_WEIGHT = 10
  };
  VW::parsers::flatbuffer::CCB_example_type example_type() const {
    return static_cast<VW::parsers::flatbuffer::CCB_example_type>(GetField<int8_t>(VT_EXAMPLE_TYPE, 0));
  }
  const VW::parsers::flatbuffer::CCB_outcome *outcome() const {
    return GetPointer<const VW::parsers::flatbuffer::CCB_outcome *>(VT_OUTCOME);
  }
  const flatbuffers::Vector<uint32_t> *explicit_included_actions() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_EXPLICIT_INCLUDED_ACTIONS);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_EXAMPLE_TYPE) &&
           VerifyOffset(verifier, VT_OUTCOME) &&
           verifier.VerifyTable(outcome()) &&
           VerifyOffset(verifier, VT_EXPLICIT_INCLUDED_ACTIONS) &&
           verifier.VerifyVector(explicit_included_actions()) &&
           VerifyField<float>(verifier, VT_WEIGHT) &&
           verifier.EndTable();
  }
};

struct CCBLabelBuilder {
  typedef CCBLabel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_example_type(VW::parsers::flatbuffer::CCB_example_type example_type) {
    fbb_.AddElement<int8_t>(CCBLabel::VT_EXAMPLE_TYPE, static_cast<int8_t>(example_type), 0);
  }
  void add_outcome(flatbuffers::Offset<VW::parsers::flatbuffer::CCB_outcome> outcome) {
    fbb_.AddOffset(CCBLabel::VT_OUTCOME, outcome);
  }
  void add_explicit_included_actions(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> explicit_included_actions) {
    fbb_.AddOffset(CCBLabel::VT_EXPLICIT_INCLUDED_ACTIONS, explicit_included_actions);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(CCBLabel::VT_WEIGHT, weight, 0.0f);
  }
  explicit CCBLabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CCBLabelBuilder &operator=(const CCBLabelBuilder &);
  flatbuffers::Offset<CCBLabel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CCBLabel>(end);
    return o;
  }
};

inline flatbuffers::Offset<CCBLabel> CreateCCBLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    VW::parsers::flatbuffer::CCB_example_type example_type = VW::parsers::flatbuffer::CCB_example_type_unset,
    flatbuffers::Offset<VW::parsers::flatbuffer::CCB_outcome> outcome = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> explicit_included_actions = 0,
    float weight = 0.0f) {
  CCBLabelBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_explicit_included_actions(explicit_included_actions);
  builder_.add_outcome(outcome);
  builder_.add_example_type(example_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CCBLabel> CreateCCBLabelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    VW::parsers::flatbuffer::CCB_example_type example_type = VW::parsers::flatbuffer::CCB_example_type_unset,
    flatbuffers::Offset<VW::parsers::flatbuffer::CCB_outcome> outcome = 0,
    const std::vector<uint32_t> *explicit_included_actions = nullptr,
    float weight = 0.0f) {
  auto explicit_included_actions__ = explicit_included_actions ? _fbb.CreateVector<uint32_t>(*explicit_included_actions) : 0;
  return VW::parsers::flatbuffer::CreateCCBLabel(
      _fbb,
      example_type,
      outcome,
      explicit_included_actions__,
      weight);
}

struct wclass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef wclassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_PARTIAL_PRED = 6,
    VT_WAP_VALUE = 8,
    VT_CLASS_INDEX = 10
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float partial_pred() const {
    return GetField<float>(VT_PARTIAL_PRED, 0.0f);
  }
  float wap_value() const {
    return GetField<float>(VT_WAP_VALUE, 0.0f);
  }
  uint32_t class_index() const {
    return GetField<uint32_t>(VT_CLASS_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_PARTIAL_PRED) &&
           VerifyField<float>(verifier, VT_WAP_VALUE) &&
           VerifyField<uint32_t>(verifier, VT_CLASS_INDEX) &&
           verifier.EndTable();
  }
};

struct wclassBuilder {
  typedef wclass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(wclass::VT_X, x, 0.0f);
  }
  void add_partial_pred(float partial_pred) {
    fbb_.AddElement<float>(wclass::VT_PARTIAL_PRED, partial_pred, 0.0f);
  }
  void add_wap_value(float wap_value) {
    fbb_.AddElement<float>(wclass::VT_WAP_VALUE, wap_value, 0.0f);
  }
  void add_class_index(uint32_t class_index) {
    fbb_.AddElement<uint32_t>(wclass::VT_CLASS_INDEX, class_index, 0);
  }
  explicit wclassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  wclassBuilder &operator=(const wclassBuilder &);
  flatbuffers::Offset<wclass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<wclass>(end);
    return o;
  }
};

inline flatbuffers::Offset<wclass> Createwclass(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float partial_pred = 0.0f,
    float wap_value = 0.0f,
    uint32_t class_index = 0) {
  wclassBuilder builder_(_fbb);
  builder_.add_class_index(class_index);
  builder_.add_wap_value(wap_value);
  builder_.add_partial_pred(partial_pred);
  builder_.add_x(x);
  return builder_.Finish();
}

struct CS_Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CS_LabelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COSTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::wclass>> *costs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::wclass>> *>(VT_COSTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COSTS) &&
           verifier.VerifyVector(costs()) &&
           verifier.VerifyVectorOfTables(costs()) &&
           verifier.EndTable();
  }
};

struct CS_LabelBuilder {
  typedef CS_Label Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_costs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::wclass>>> costs) {
    fbb_.AddOffset(CS_Label::VT_COSTS, costs);
  }
  explicit CS_LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CS_LabelBuilder &operator=(const CS_LabelBuilder &);
  flatbuffers::Offset<CS_Label> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CS_Label>(end);
    return o;
  }
};

inline flatbuffers::Offset<CS_Label> CreateCS_Label(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::wclass>>> costs = 0) {
  CS_LabelBuilder builder_(_fbb);
  builder_.add_costs(costs);
  return builder_.Finish();
}

inline flatbuffers::Offset<CS_Label> CreateCS_LabelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<VW::parsers::flatbuffer::wclass>> *costs = nullptr) {
  auto costs__ = costs ? _fbb.CreateVector<flatbuffers::Offset<VW::parsers::flatbuffer::wclass>>(*costs) : 0;
  return VW::parsers::flatbuffer::CreateCS_Label(
      _fbb,
      costs__);
}

struct no_label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef no_labelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4
  };
  uint8_t label() const {
    return GetField<uint8_t>(VT_LABEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LABEL) &&
           verifier.EndTable();
  }
};

struct no_labelBuilder {
  typedef no_label Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(uint8_t label) {
    fbb_.AddElement<uint8_t>(no_label::VT_LABEL, label, 0);
  }
  explicit no_labelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  no_labelBuilder &operator=(const no_labelBuilder &);
  flatbuffers::Offset<no_label> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<no_label>(end);
    return o;
  }
};

inline flatbuffers::Offset<no_label> Createno_label(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t label = 0) {
  no_labelBuilder builder_(_fbb);
  builder_.add_label(label);
  return builder_.Finish();
}

struct Example FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExampleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAMESPACES = 4,
    VT_LABEL_TYPE = 6,
    VT_LABEL = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Namespace>> *namespaces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Namespace>> *>(VT_NAMESPACES);
  }
  VW::parsers::flatbuffer::Label label_type() const {
    return static_cast<VW::parsers::flatbuffer::Label>(GetField<uint8_t>(VT_LABEL_TYPE, 0));
  }
  const void *label() const {
    return GetPointer<const void *>(VT_LABEL);
  }
  template<typename T> const T *label_as() const;
  const VW::parsers::flatbuffer::SimpleLabel *label_as_SimpleLabel() const {
    return label_type() == VW::parsers::flatbuffer::Label_SimpleLabel ? static_cast<const VW::parsers::flatbuffer::SimpleLabel *>(label()) : nullptr;
  }
  const VW::parsers::flatbuffer::CBLabel *label_as_CBLabel() const {
    return label_type() == VW::parsers::flatbuffer::Label_CBLabel ? static_cast<const VW::parsers::flatbuffer::CBLabel *>(label()) : nullptr;
  }
  const VW::parsers::flatbuffer::CCBLabel *label_as_CCBLabel() const {
    return label_type() == VW::parsers::flatbuffer::Label_CCBLabel ? static_cast<const VW::parsers::flatbuffer::CCBLabel *>(label()) : nullptr;
  }
  const VW::parsers::flatbuffer::MultiClass *label_as_MultiClass() const {
    return label_type() == VW::parsers::flatbuffer::Label_MultiClass ? static_cast<const VW::parsers::flatbuffer::MultiClass *>(label()) : nullptr;
  }
  const VW::parsers::flatbuffer::MultiLabel *label_as_MultiLabel() const {
    return label_type() == VW::parsers::flatbuffer::Label_MultiLabel ? static_cast<const VW::parsers::flatbuffer::MultiLabel *>(label()) : nullptr;
  }
  const VW::parsers::flatbuffer::CB_EVAL_Label *label_as_CB_EVAL_Label() const {
    return label_type() == VW::parsers::flatbuffer::Label_CB_EVAL_Label ? static_cast<const VW::parsers::flatbuffer::CB_EVAL_Label *>(label()) : nullptr;
  }
  const VW::parsers::flatbuffer::CS_Label *label_as_CS_Label() const {
    return label_type() == VW::parsers::flatbuffer::Label_CS_Label ? static_cast<const VW::parsers::flatbuffer::CS_Label *>(label()) : nullptr;
  }
  const VW::parsers::flatbuffer::no_label *label_as_no_label() const {
    return label_type() == VW::parsers::flatbuffer::Label_no_label ? static_cast<const VW::parsers::flatbuffer::no_label *>(label()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAMESPACES) &&
           verifier.VerifyVector(namespaces()) &&
           verifier.VerifyVectorOfTables(namespaces()) &&
           VerifyField<uint8_t>(verifier, VT_LABEL_TYPE) &&
           VerifyOffset(verifier, VT_LABEL) &&
           VerifyLabel(verifier, label(), label_type()) &&
           verifier.EndTable();
  }
};

template<> inline const VW::parsers::flatbuffer::SimpleLabel *Example::label_as<VW::parsers::flatbuffer::SimpleLabel>() const {
  return label_as_SimpleLabel();
}

template<> inline const VW::parsers::flatbuffer::CBLabel *Example::label_as<VW::parsers::flatbuffer::CBLabel>() const {
  return label_as_CBLabel();
}

template<> inline const VW::parsers::flatbuffer::CCBLabel *Example::label_as<VW::parsers::flatbuffer::CCBLabel>() const {
  return label_as_CCBLabel();
}

template<> inline const VW::parsers::flatbuffer::MultiClass *Example::label_as<VW::parsers::flatbuffer::MultiClass>() const {
  return label_as_MultiClass();
}

template<> inline const VW::parsers::flatbuffer::MultiLabel *Example::label_as<VW::parsers::flatbuffer::MultiLabel>() const {
  return label_as_MultiLabel();
}

template<> inline const VW::parsers::flatbuffer::CB_EVAL_Label *Example::label_as<VW::parsers::flatbuffer::CB_EVAL_Label>() const {
  return label_as_CB_EVAL_Label();
}

template<> inline const VW::parsers::flatbuffer::CS_Label *Example::label_as<VW::parsers::flatbuffer::CS_Label>() const {
  return label_as_CS_Label();
}

template<> inline const VW::parsers::flatbuffer::no_label *Example::label_as<VW::parsers::flatbuffer::no_label>() const {
  return label_as_no_label();
}

struct ExampleBuilder {
  typedef Example Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_namespaces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Namespace>>> namespaces) {
    fbb_.AddOffset(Example::VT_NAMESPACES, namespaces);
  }
  void add_label_type(VW::parsers::flatbuffer::Label label_type) {
    fbb_.AddElement<uint8_t>(Example::VT_LABEL_TYPE, static_cast<uint8_t>(label_type), 0);
  }
  void add_label(flatbuffers::Offset<void> label) {
    fbb_.AddOffset(Example::VT_LABEL, label);
  }
  explicit ExampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExampleBuilder &operator=(const ExampleBuilder &);
  flatbuffers::Offset<Example> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Example>(end);
    return o;
  }
};

inline flatbuffers::Offset<Example> CreateExample(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Namespace>>> namespaces = 0,
    VW::parsers::flatbuffer::Label label_type = VW::parsers::flatbuffer::Label_NONE,
    flatbuffers::Offset<void> label = 0) {
  ExampleBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_namespaces(namespaces);
  builder_.add_label_type(label_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Example> CreateExampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<VW::parsers::flatbuffer::Namespace>> *namespaces = nullptr,
    VW::parsers::flatbuffer::Label label_type = VW::parsers::flatbuffer::Label_NONE,
    flatbuffers::Offset<void> label = 0) {
  auto namespaces__ = namespaces ? _fbb.CreateVector<flatbuffers::Offset<VW::parsers::flatbuffer::Namespace>>(*namespaces) : 0;
  return VW::parsers::flatbuffer::CreateExample(
      _fbb,
      namespaces__,
      label_type,
      label);
}

struct ExampleCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExampleCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXAMPLES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Example>> *examples() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Example>> *>(VT_EXAMPLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXAMPLES) &&
           verifier.VerifyVector(examples()) &&
           verifier.VerifyVectorOfTables(examples()) &&
           verifier.EndTable();
  }
};

struct ExampleCollectionBuilder {
  typedef ExampleCollection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_examples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Example>>> examples) {
    fbb_.AddOffset(ExampleCollection::VT_EXAMPLES, examples);
  }
  explicit ExampleCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExampleCollectionBuilder &operator=(const ExampleCollectionBuilder &);
  flatbuffers::Offset<ExampleCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExampleCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExampleCollection> CreateExampleCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VW::parsers::flatbuffer::Example>>> examples = 0) {
  ExampleCollectionBuilder builder_(_fbb);
  builder_.add_examples(examples);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExampleCollection> CreateExampleCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<VW::parsers::flatbuffer::Example>> *examples = nullptr) {
  auto examples__ = examples ? _fbb.CreateVector<flatbuffers::Offset<VW::parsers::flatbuffer::Example>>(*examples) : 0;
  return VW::parsers::flatbuffer::CreateExampleCollection(
      _fbb,
      examples__);
}

inline bool VerifyLabel(flatbuffers::Verifier &verifier, const void *obj, Label type) {
  switch (type) {
    case Label_NONE: {
      return true;
    }
    case Label_SimpleLabel: {
      auto ptr = reinterpret_cast<const VW::parsers::flatbuffer::SimpleLabel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Label_CBLabel: {
      auto ptr = reinterpret_cast<const VW::parsers::flatbuffer::CBLabel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Label_CCBLabel: {
      auto ptr = reinterpret_cast<const VW::parsers::flatbuffer::CCBLabel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Label_MultiClass: {
      auto ptr = reinterpret_cast<const VW::parsers::flatbuffer::MultiClass *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Label_MultiLabel: {
      auto ptr = reinterpret_cast<const VW::parsers::flatbuffer::MultiLabel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Label_CB_EVAL_Label: {
      auto ptr = reinterpret_cast<const VW::parsers::flatbuffer::CB_EVAL_Label *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Label_CS_Label: {
      auto ptr = reinterpret_cast<const VW::parsers::flatbuffer::CS_Label *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Label_no_label: {
      auto ptr = reinterpret_cast<const VW::parsers::flatbuffer::no_label *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLabelVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLabel(
        verifier,  values->Get(i), types->GetEnum<Label>(i))) {
      return false;
    }
  }
  return true;
}

inline const VW::parsers::flatbuffer::ExampleCollection *GetExampleCollection(const void *buf) {
  return flatbuffers::GetRoot<VW::parsers::flatbuffer::ExampleCollection>(buf);
}

inline const VW::parsers::flatbuffer::ExampleCollection *GetSizePrefixedExampleCollection(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<VW::parsers::flatbuffer::ExampleCollection>(buf);
}

inline bool VerifyExampleCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<VW::parsers::flatbuffer::ExampleCollection>(nullptr);
}

inline bool VerifySizePrefixedExampleCollectionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<VW::parsers::flatbuffer::ExampleCollection>(nullptr);
}

inline void FinishExampleCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<VW::parsers::flatbuffer::ExampleCollection> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedExampleCollectionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<VW::parsers::flatbuffer::ExampleCollection> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuffer
}  // namespace parsers
}  // namespace VW

#endif  // FLATBUFFERS_GENERATED_EXAMPLE_VW_PARSERS_FLATBUFFER_H_
